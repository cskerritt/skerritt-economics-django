name: Build and Deploy to AWS Lightsail

# Trigger deployment on push to main branch
on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual trigger

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
    - name: Deploy to Lightsail via SSH
      env:
        LIGHTSAIL_HOST: ${{ secrets.LIGHTSAIL_HOST }}
        LIGHTSAIL_USERNAME: ${{ secrets.LIGHTSAIL_USERNAME }}
        LIGHTSAIL_KEY: ${{ secrets.LIGHTSAIL_KEY }}
        LIGHTSAIL_PORT: ${{ secrets.LIGHTSAIL_PORT }}
      run: |
        echo "üöÄ Starting deployment to Lightsail..."
        
        # Create SSH key file
        echo "$LIGHTSAIL_KEY" > lightsail_key
        chmod 600 lightsail_key
        
        # Add host to known hosts
        mkdir -p ~/.ssh
        ssh-keyscan -H -p ${LIGHTSAIL_PORT:-22} $LIGHTSAIL_HOST >> ~/.ssh/known_hosts 2>/dev/null
        
        # Deploy using SSH
        ssh -i lightsail_key -p ${LIGHTSAIL_PORT:-22} ${LIGHTSAIL_USERNAME}@${LIGHTSAIL_HOST} << 'ENDSSH'
          set -e
          echo "üì¶ Updating application..."
          
          # Navigate to app directory
          cd /home/bitnami/skerritt-economics-django || cd /opt/skerritt-economics || cd ~/skerritt-economics-django
          
          # Pull latest changes from git (force merge strategy for divergent branches)
          git fetch origin main
          git reset --hard origin/main
          
          # Ensure .env file exists (copy from example if needed)
          if [ ! -f ".env" ]; then
            if [ -f ".env.example" ]; then
              echo "‚ö†Ô∏è Creating .env file from example..."
              cp .env.example .env
            else
              echo "‚ö†Ô∏è Creating basic .env file..."
              touch .env
            fi
          fi
          
          # Ensure critical environment variables are set
          if ! grep -q "DJANGO_SECRET_KEY=" .env || grep -q "MUST_BE_SET_IN_PRODUCTION" .env; then
            echo "üîê Generating secure Django secret key..."
            SECRET_KEY=$(python3 -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())')
            if grep -q "DJANGO_SECRET_KEY=" .env; then
              sed -i "s/DJANGO_SECRET_KEY=.*/DJANGO_SECRET_KEY=$SECRET_KEY/" .env
            else
              echo "DJANGO_SECRET_KEY=$SECRET_KEY" >> .env
            fi
          fi
          
          # Ensure Django settings module is set
          if ! grep -q "DJANGO_SETTINGS_MODULE=" .env; then
            echo "DJANGO_SETTINGS_MODULE=skerritt_site.settings_production" >> .env
          fi
          
          # Ensure allowed hosts is set
          if ! grep -q "DJANGO_ALLOWED_HOSTS=" .env; then
            echo "DJANGO_ALLOWED_HOSTS=skerritteconomics.com,www.skerritteconomics.com,localhost,$(hostname -I | awk '{print $1}')" >> .env
          fi
          
          # Export variables for current session
          export $(cat .env | grep -v '^#' | xargs)
          
          # Check deployment method and deploy
          # Prioritize Docker if docker-compose.yml exists
          if [ -f "docker-compose.yml" ] && command -v docker &> /dev/null; then
            echo "Deploying with Docker Compose..."
            
            # Pull the latest image
            echo "Pulling latest Docker image..."
            docker compose pull || docker-compose pull
            
            # Stop existing containers
            echo "Stopping existing containers..."
            docker compose down || docker-compose down
            
            # Start new containers
            echo "Starting new containers..."
            docker compose up -d || docker-compose up -d
            
            # Wait for containers to be ready
            echo "Waiting for containers to start..."
            sleep 10
            
            # Check container status
            docker compose ps || docker-compose ps
            
            # Run migrations inside container
            echo "Running Django migrations..."
            docker compose exec -T django python manage.py migrate --noinput || \
              docker-compose exec -T django python manage.py migrate --noinput || \
              echo "‚ö†Ô∏è Could not run migrations"
            
            # Collect static files
            echo "Collecting static files..."
            docker compose exec -T django python manage.py collectstatic --noinput || \
              docker-compose exec -T django python manage.py collectstatic --noinput || \
              echo "‚ö†Ô∏è Could not collect static files"
            
            # Show logs for debugging
            echo "Recent Django container logs:"
            docker compose logs --tail=20 django || docker-compose logs --tail=20 django
          elif [ -f "deploy.sh" ]; then
            echo "Running local deployment script..."
            chmod +x deploy.sh
            ./deploy.sh
          elif [ -f "/usr/local/bin/deploy_app.sh" ]; then
            echo "Running system deployment script..."
            /usr/local/bin/deploy_app.sh
          elif [ -f "venv/bin/activate" ]; then
            echo "Deploying with virtual environment..."
            source venv/bin/activate
            pip install -r requirements.txt
            python manage.py migrate --noinput
            python manage.py collectstatic --noinput
            
            # Restart services
            if systemctl is-active --quiet skerritt-economics; then
              sudo systemctl restart skerritt-economics
            elif systemctl is-active --quiet gunicorn; then
              sudo systemctl restart gunicorn
            fi
            
            if systemctl is-active --quiet nginx; then
              sudo systemctl reload nginx
            fi
          else
            echo "‚ùå No valid deployment method found!"
            exit 1
          fi
          
          echo "‚úÖ Deployment complete!"
          
          # Run diagnostics to check deployment status
          if [ -f "diagnose_deployment.sh" ]; then
            echo "üîç Running deployment diagnostics..."
            chmod +x diagnose_deployment.sh
            ./diagnose_deployment.sh || true
          fi
        ENDSSH
        
        # Clean up
        rm -f lightsail_key
        
    - name: Verify deployment
      env:
        SITE_URL: ${{ secrets.SITE_URL }}
      run: |
        echo "üîç Verifying deployment..."
        sleep 15  # Wait for services to fully start
        
        # Determine URL to check
        URL="${SITE_URL:-http://${{ secrets.LIGHTSAIL_HOST }}}"
        echo "Checking URL: $URL"
        
        # Check if site is responding (with retries)
        MAX_RETRIES=3
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          response=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
          
          if [ "$response" = "200" ] || [ "$response" = "301" ] || [ "$response" = "302" ]; then
            echo "‚úÖ Site is responding with status: $response"
            exit 0
          elif [ "$response" = "500" ] || [ "$response" = "502" ] || [ "$response" = "503" ]; then
            echo "‚ö†Ô∏è Server error detected (HTTP $response). Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
            if [ $RETRY_COUNT -eq $((MAX_RETRIES - 1)) ]; then
              echo "‚ùå Deployment verification failed after $MAX_RETRIES attempts"
              echo "Please check server logs for details"
              exit 1
            fi
            sleep 10
          else
            echo "‚ö†Ô∏è Unexpected status: $response. Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
            sleep 10
          fi
          
          RETRY_COUNT=$((RETRY_COUNT + 1))
        done
        
        echo "‚ùå Site verification failed after $MAX_RETRIES attempts"
        exit 1
    
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "‚úÖ Deployment to Lightsail successful!"
        else
          echo "‚ùå Deployment to Lightsail failed!"
        fi